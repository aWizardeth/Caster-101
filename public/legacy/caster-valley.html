<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>üßô‚Äç‚ôÇÔ∏è Caster Valley 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Nunito:wght@400;600;700;800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        :root {
            --cream: #fef6e4; --sand: #f3d5b5; --brown-light: #8b6f47; --brown-med: #6d5633;
            --brown-dark: #533d2b; --green-light: #b8d48e; --green-med: #7ba05b; --green-dark: #5a7647;
            --blue-sky: #87ceeb; --orange: #f4a261; --red: #c9562c; --gold: #ffd700; --purple: #9d84b7;
        }
        body {
            font-family: 'Nunito', sans-serif; background: linear-gradient(180deg, var(--blue-sky) 0%, var(--green-light) 100%);
            color: var(--brown-dark); overflow: hidden; height: 100vh; touch-action: none;
            transition: background 1.5s ease;
        }
        body.night-mode {
            background: linear-gradient(180deg, #1a1a3e 0%, #0f1a2e 100%);
        }
        body.fullscreen-mode {
            overflow: hidden !important;
            position: fixed;
            width: 100vw;
            height: 100vh;
            top: 0;
            left: 0;
        }
        #game-container { position: relative; width: 100%; height: 100vh; display: flex; flex-direction: column; }
        #hud {
            background: linear-gradient(180deg, var(--brown-light) 0%, var(--brown-med) 100%); border-bottom: 4px solid var(--brown-dark);
            box-shadow: 0 4px 0 var(--brown-dark), inset 0 2px 0 var(--sand); padding: 12px; display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center; z-index: 100;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 8px; }
        .hud-center { text-align: center; }
        .stat-row { display: flex; align-items: center; gap: 8px; font-size: 10px; }
        .stat-icon { font-size: 24px; filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.3)); }
        .bar-container {
            flex: 1; height: 22px; background: var(--brown-dark); border: 3px solid var(--sand); border-radius: 6px; overflow: hidden;
            position: relative; box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.5);
        }
        .bar-fill { height: 100%; transition: width 0.4s ease; position: relative; }
        .bar-fill::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 40%; background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%); }
        .hp-bar { background: linear-gradient(90deg, #c9562c 0%, #f4a261 100%); }
        .xp-bar { background: linear-gradient(90deg, #9d84b7 0%, #d0c4e3 100%); }
        .bar-text {
            font-family: 'Press Start 2P', cursive; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 7px; color: var(--cream);
            text-shadow: 2px 2px 0 var(--brown-dark); z-index: 1;
        }
        .wizard-level {
            font-family: 'Press Start 2P', cursive; font-size: 20px; color: var(--gold); text-shadow: 3px 3px 0 var(--brown-dark);
            animation: shine 2s ease-in-out infinite; margin-bottom: 6px;
        }
        @keyframes shine { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        .resource-display { font-family: 'Press Start 2P', cursive; font-size: 11px; color: var(--cream); text-shadow: 2px 2px 0 var(--brown-dark); display: flex; align-items: center; justify-content: center; gap: 6px; }
        .menu-buttons { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
        .menu-btn {
            font-family: 'Press Start 2P', cursive; background: linear-gradient(180deg, var(--brown-light) 0%, var(--brown-med) 100%); border: 3px solid var(--sand); color: var(--cream);
            padding: 8px 12px; border-radius: 6px; font-size: 7px; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 4px 0 var(--brown-dark), inset 0 1px 0 rgba(255, 255, 255, 0.3); text-shadow: 1px 1px 0 var(--brown-dark);
            min-width: 40px; min-height: 40px; display: flex; align-items: center; justify-content: center;
        }
        .menu-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 var(--brown-dark); filter: brightness(1.1); }
        .menu-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        #game-world { flex: 1; position: relative; overflow: hidden; background: transparent; }
        #game-canvas { width: 100%; height: 100%; display: block; background: transparent; }
        #toolbar {
            background: linear-gradient(0deg, var(--brown-light) 0%, var(--brown-med) 100%); border-top: 4px solid var(--brown-dark);
            box-shadow: 0 -4px 0 var(--brown-dark), inset 0 -2px 0 var(--sand); padding: 6px; display: flex; gap: 6px; overflow-x: auto; z-index: 100;
        }
        .tool-item, .seed-item, .area-btn {
            flex: 0 1 auto; min-width: 55px; max-width: 70px; height: 65px; background: linear-gradient(135deg, var(--sand) 0%, var(--brown-light) 100%);
            border: 3px solid var(--brown-dark); border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; padding: 4px; box-shadow: 0 4px 0 var(--brown-dark), inset 0 2px 0 rgba(255, 255, 255, 0.3);
        }
        .tool-item:active, .seed-item:active, .area-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        .tool-icon, .seed-icon { font-size: 24px; margin-bottom: 2px; filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.3)); }
        .tool-label, .seed-label {
            font-family: 'Press Start 2P', cursive; font-size: 6px; text-align: center; line-height: 1.2; text-transform: uppercase;
            color: var(--brown-dark); text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        }
        .seed-count {
            position: absolute; top: 2px; right: 2px; background: var(--red); color: var(--cream); border-radius: 50%;
            min-width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 8px;
            border: 2px solid var(--brown-dark); box-shadow: 0 2px 4px rgba(0,0,0,0.3); text-shadow: 1px 1px 0 var(--brown-dark);
            font-weight: bold;
        }
        .area-btn { background: linear-gradient(135deg, var(--green-light), var(--green-med)); border-color: var(--green-dark); min-width: 48px; min-height: 48px; }
        .area-btn.active { box-shadow: 0 4px 0 var(--green-dark), 0 0 20px var(--gold), inset 0 0 20px rgba(255, 255, 255, 0.3); border-color: var(--gold); }
        
        .left-tabs {
            position: fixed; left: 10px; top: 100px; z-index: 150;
            display: flex; flex-direction: column; gap: 6px;
        }
        .left-tab {
            width: 50px; height: 50px; background: linear-gradient(135deg, var(--green-med), var(--green-dark));
            border: 3px solid var(--brown-dark); border-radius: 8px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.3s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .left-tab:hover {
            transform: translateX(3px) scale(1.05); box-shadow: 0 6px 15px rgba(0,0,0,0.7);
            background: linear-gradient(135deg, var(--green-dark), #2d5016);
        }
        .left-tab.active {
            background: linear-gradient(135deg, #ffd700, #d4af37);
            transform: translateX(6px) scale(1.08); box-shadow: 0 8px 20px rgba(255,215,0,0.6);
        }
        .left-tab.locked {
            opacity: 0.4; cursor: not-allowed; background: linear-gradient(135deg, #666, #444);
        }
        .left-tab.locked:hover {
            transform: none; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .left-tab-icon {
            font-size: 22px; filter: drop-shadow(1px 1px 3px rgba(0,0,0,0.7));
        }
        .left-tab-label {
            font-family: 'Press Start 2P'; font-size: 5px; color: white; text-align: center;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9); margin-top: 2px;
        }
        
        .recenter-btn {
            position: fixed; bottom: 90px; left: 20px; width: 45px; height: 45px;
            background: linear-gradient(135deg, var(--orange), var(--red));
            border: 3px solid var(--brown-dark); border-radius: 50%;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 3px 0 var(--brown-dark), 0 5px 12px rgba(0,0,0,0.4);
            z-index: 150; font-size: 22px;
        }
        .recenter-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 0 var(--brown-dark), 0 8px 16px rgba(0,0,0,0.5);
        }
        .recenter-btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 0 var(--brown-dark), 0 3px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div class="hud-left">
                <div class="stat-row"><span class="stat-icon">‚ù§Ô∏è</span><div class="bar-container"><div class="bar-fill hp-bar" id="hp-bar" style="width: 100%"></div><div class="bar-text" id="hp-text">100/100</div></div></div>
                <div class="stat-row"><span class="stat-icon">‚ú®</span><div class="bar-container"><div class="bar-fill xp-bar" id="xp-bar" style="width: 0%"></div><div class="bar-text" id="xp-text">0/100</div></div></div>
            </div>
            <div class="hud-center"><div class="wizard-level" id="level-display">LVL 1</div><div class="resource-display"><span class="resource-icon">‚ö°ü™Ñ</span><span id="essence-display">0</span><span style="font-size: 9px; margin-left: 3px;">SP</span></div></div>
            <div class="hud-right">
                <div class="stat-row">
                    <span class="stat-icon" id="day-night-icon">‚òÄÔ∏è</span>
                    <span id="day-night-text" style="font-size: 8px; color: var(--cream); text-shadow: 1px 1px 0 var(--brown-dark);">Day</span>
                    <span class="stat-icon" id="weather-icon" style="font-size: 20px; margin-left: 8px;">‚òÅÔ∏è</span>
                </div>
                <div class="menu-buttons">
                    <button class="menu-btn" onclick="game.openModal('tutorial')">‚ùì</button>
                    <button class="menu-btn" onclick="game.openModal('achievements')">üèÜ</button>
                    <button class="menu-btn" onclick="game.openModal('stats')">üìä</button>
                    <button class="menu-btn" onclick="game.toggleFullscreen()">‚õ∂</button>
                </div>
            </div>
        </div>
        <div id="game-world"><canvas id="game-canvas"></canvas></div>
        <div id="toolbar"></div>
        
        <div class="left-tabs">
            <div class="left-tab" id="farm-tab" onclick="game.switchArea('farm')" title="Farm">
                <div class="left-tab-icon">üåæ</div>
                <div class="left-tab-label">FARM</div>
            </div>
            <div class="left-tab" id="forest-tab" onclick="game.switchArea('forest')" title="Forest">
                <div class="left-tab-icon">üå≤</div>
                <div class="left-tab-label">FOREST</div>
            </div>
            <div class="left-tab" id="mine-tab" onclick="game.switchArea('mine')" title="Mine">
                <div class="left-tab-icon">‚õèÔ∏è</div>
                <div class="left-tab-label">MINE</div>
            </div>
            <div class="left-tab" id="fishing-tab" onclick="game.switchArea('fishing')" title="Fishing">
                <div class="left-tab-icon">üé£</div>
                <div class="left-tab-label">FISHING</div>
            </div>
        </div>
        
        <button class="recenter-btn" onclick="game.recenterCamera()" title="Recenter Camera">üéØ</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const SEED_TIERS = [
            { tier: 1, icon: 'üå±', color: 0xc9562c, sp: 3, sellPrice: 2, name: 'Embersprout' },
            { tier: 2, icon: 'üå∫', color: 0xf4a261, sp: 8, sellPrice: 5, name: 'Sunpetal' },
            { tier: 3, icon: 'üçÉ', color: 0xe9c46a, sp: 18, sellPrice: 12, name: 'Goldleaf' },
            { tier: 4, icon: 'ü™∑', color: 0xb8d48e, sp: 35, sellPrice: 25, name: 'Lotus Dream' },
            { tier: 5, icon: 'üåπ', color: 0x7ba05b, sp: 65, sellPrice: 50, name: 'Thornvine' },
        ];
        
        const game = {
            essence: 0, hp: 100, maxHP: 100, level: 1, xp: 0, xpNeeded: 100,
            currentArea: 'farm', isDayTime: true, purchasedSkills: [], 
            seeds: { 1: 5 }, unlockedAreas: { farm: true, mine: false, forest: false, fishing: false },
            farmPlots: [], mineRocks: [], forestTrolls: [], 
            areaObjects: [],
            selectedSeed: null, draggedSeed: null, ghostElement: null, isDragging: false,
            scene: null, camera: null, renderer: null, raycaster: null, mouse: null, wizard: null,
            wizardTarget: { x: -6, z: 0 }, wizardMoving: false,
            stats: { totalHarvests: 0, totalRocksMined: 0, totalTrollsKilled: 0, playtime: 0, deathCount: 0 },
            completedAchievements: [], weather: 'clear', weatherParticles: [],
            cameraTarget: { x: 0, y: 0, z: 0 },
            cameraOffset: { x: 0, y: 28, z: 15 },
            defaultCameraOffset: { x: 0, y: 28, z: 15 },
            isDraggingCamera: false,
            previousPointerPosition: { x: 0, y: 0 },
            panSpeed: 0.05,
            maxPanX: 25,
            maxPanZ: 25,
            isRecentering: false,
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 2.0,

            init() {
                this.loadGame();
                if (Object.keys(this.seeds).length === 0 || !this.seeds[1]) {
                    this.seeds = { 1: 5 };
                }
                this.setupThreeJS();
                this.createWorld();
                this.createWizard();
                this.renderToolbar();
                this.setupEventListeners();
                this.updateUI();
                this.animate();
                setInterval(() => this.tick(), 100);
                setInterval(() => { if (this.hp < this.maxHP) { this.hp = Math.min(this.maxHP, this.hp + 1); this.updateUI(); } }, 5000);
                setInterval(() => this.stats.playtime++, 1000);
                setInterval(() => { this.isDayTime = !this.isDayTime; this.updateUI(); this.updateDayNightVisuals(); }, 60000);
                setInterval(() => this.saveGame(), 10000);
                console.log('üéÆ Caster Valley ready!');
            },

            saveGame() {
                try {
                    const saveData = {
                        essence: this.essence, hp: this.hp, maxHP: this.maxHP, level: this.level, xp: this.xp, xpNeeded: this.xpNeeded,
                        currentArea: this.currentArea, isDayTime: this.isDayTime,
                        purchasedSkills: this.purchasedSkills, seeds: this.seeds, unlockedAreas: this.unlockedAreas,
                        stats: this.stats, completedAchievements: this.completedAchievements, version: '1.0'
                    };
                    localStorage.setItem('casterValleySave', JSON.stringify(saveData));
                } catch (e) {
                    console.error('Save failed:', e);
                }
            },

            loadGame() {
                try {
                    const saved = localStorage.getItem('casterValleySave');
                    if (saved) {
                        const d = JSON.parse(saved);
                        if (d.version === '1.0') {
                            this.essence = d.essence || 0; this.hp = d.hp || 100; this.maxHP = d.maxHP || 100;
                            this.level = d.level || 1; this.xp = d.xp || 0; this.xpNeeded = d.xpNeeded || 100;
                            this.currentArea = d.currentArea || 'farm'; this.isDayTime = d.isDayTime !== undefined ? d.isDayTime : true;
                            this.purchasedSkills = d.purchasedSkills || []; 
                            this.seeds = d.seeds || { 1: 5 };
                            if (!this.seeds[1] || this.seeds[1] <= 0) {
                                this.seeds[1] = 5;
                            }
                            this.unlockedAreas = d.unlockedAreas || { farm: true, mine: false, forest: false, fishing: false };
                            this.stats = d.stats || { totalHarvests: 0, totalRocksMined: 0, totalTrollsKilled: 0, playtime: 0, deathCount: 0 };
                            this.completedAchievements = d.completedAchievements || [];
                        }
                    }
                } catch (e) {
                    console.error('Load failed:', e);
                }
            },

            updateDayNightVisuals() {
                if (this.isDayTime) {
                    document.body.classList.remove('night-mode');
                } else {
                    document.body.classList.add('night-mode');
                }
            },

            setupThreeJS() {
                const canvas = document.getElementById('game-canvas');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb);
                
                this.camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
                this.camera.position.set(
                    this.cameraTarget.x + this.cameraOffset.x,
                    this.cameraTarget.y + this.cameraOffset.y,
                    this.cameraTarget.z + this.cameraOffset.z
                );
                this.camera.lookAt(this.cameraTarget.x, this.cameraTarget.y, this.cameraTarget.z);
                
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.setClearColor(0x000000, 0);
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const sunLight = new THREE.DirectionalLight(0xffd700, 0.8);
                sunLight.position.set(10, 20, 10);
                sunLight.castShadow = true;
                this.scene.add(sunLight);
                
                const groundGeo = new THREE.PlaneGeometry(100, 100);
                const groundMat = new THREE.MeshLambertMaterial({ color: 0x7ba05b });
                this.ground = new THREE.Mesh(groundGeo, groundMat);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                });
                
                this.setupCameraControls();
            },
            
            setupCameraControls() {
                const canvas = document.getElementById('game-canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.isDraggingCamera = true;
                        this.previousPointerPosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.isDraggingCamera) {
                        const deltaX = e.clientX - this.previousPointerPosition.x;
                        const deltaY = e.clientY - this.previousPointerPosition.y;
                        
                        // Intuitive dragging: drag right = move camera right, drag down = move camera down
                        this.cameraTarget.x -= deltaX * this.panSpeed;
                        this.cameraTarget.z -= deltaY * this.panSpeed;
                        
                        this.cameraTarget.x = Math.max(-this.maxPanX, Math.min(this.maxPanX, this.cameraTarget.x));
                        this.cameraTarget.z = Math.max(-this.maxPanZ, Math.min(this.maxPanZ, this.cameraTarget.z));
                        
                        this.previousPointerPosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.isDraggingCamera = false;
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.isDraggingCamera = false;
                });
                
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.isDraggingCamera = true;
                        this.previousPointerPosition = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (this.isDraggingCamera && e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - this.previousPointerPosition.x;
                        const deltaY = e.touches[0].clientY - this.previousPointerPosition.y;
                        
                        this.cameraTarget.x -= deltaX * this.panSpeed;
                        this.cameraTarget.z -= deltaY * this.panSpeed;
                        
                        this.cameraTarget.x = Math.max(-this.maxPanX, Math.min(this.maxPanX, this.cameraTarget.x));
                        this.cameraTarget.z = Math.max(-this.maxPanZ, Math.min(this.maxPanZ, this.cameraTarget.z));
                        
                        this.previousPointerPosition = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });
                
                canvas.addEventListener('touchend', () => {
                    this.isDraggingCamera = false;
                });
            },
            
            recenterCamera() {
                this.isRecentering = true;
                const duration = 1000;
                const startTime = Date.now();
                const startTarget = { ...this.cameraTarget };
                const startZoom = this.zoom;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    this.cameraTarget.x = startTarget.x + (0 - startTarget.x) * eased;
                    this.cameraTarget.z = startTarget.z + (0 - startTarget.z) * eased;
                    this.zoom = startZoom + (1.0 - startZoom) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isRecentering = false;
                    }
                };
                
                animate();
            },
            
            updateCamera() {
                const zoomedOffsetX = this.cameraOffset.x / this.zoom;
                const zoomedOffsetY = this.cameraOffset.y / this.zoom;
                const zoomedOffsetZ = this.cameraOffset.z / this.zoom;
                
                const targetX = this.cameraTarget.x + zoomedOffsetX;
                const targetY = this.cameraTarget.y + zoomedOffsetY;
                const targetZ = this.cameraTarget.z + zoomedOffsetZ;
                
                this.camera.position.x += (targetX - this.camera.position.x) * 0.15;
                this.camera.position.y += (targetY - this.camera.position.y) * 0.15;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.15;
                
                this.camera.lookAt(this.cameraTarget.x, this.cameraTarget.y, this.cameraTarget.z);
            },

            clearAreaObjects() {
                this.areaObjects.forEach(obj => {
                    if (obj.parent) this.scene.remove(obj);
                });
                this.areaObjects = [];
                this.farmPlots = [];
                this.mineRocks = [];
                this.forestTrolls = [];
            },

            createWorld() {
                this.clearAreaObjects();
                if (this.currentArea === 'farm') {
                    this.createFarm();
                } else if (this.currentArea === 'mine') {
                    this.createMine();
                } else if (this.currentArea === 'forest') {
                    this.createForest();
                } else if (this.currentArea === 'fishing') {
                    this.createFishing();
                }
                this.updateDayNightVisuals();
            },

            createFarm() {
                this.scene.background = new THREE.Color(0x87ceeb);
                this.ground.material.color.setHex(0x7ba05b);
                
                const total = 12;
                for (let i = 0; i < total; i++) {
                    const col = i % 4;
                    const row = Math.floor(i / 4);
                    const x = (col - 1.5) * 3.5;
                    const z = (row - Math.floor(total / 4) / 2) * 3.5;
                    
                    const plot = new THREE.Mesh(new THREE.BoxGeometry(2, 0.3, 2), new THREE.MeshLambertMaterial({ color: 0x6d5633 }));
                    plot.position.set(x, 0.15, z);
                    plot.castShadow = true;
                    plot.receiveShadow = true;
                    this.scene.add(plot);
                    this.areaObjects.push(plot);
                    
                    this.farmPlots.push({ mesh: plot, x, z, seed: null, growthTime: 0, growthNeeded: 15000, plantMesh: null });
                }
            },

            createMine() {
                this.scene.background = new THREE.Color(0x2c2c2c);
                this.ground.material.color.setHex(0x6d4c2f);
                
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const distance = 35 + Math.sin(i * 0.5) * 6 + (Math.random() - 0.5) * 3;
                    
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const nextAngle = ((i + 1) / 30) * Math.PI * 2;
                    const nextDistance = 35 + Math.sin((i + 1) * 0.5) * 6 + (Math.random() - 0.5) * 3;
                    const nextX = Math.cos(nextAngle) * nextDistance;
                    const nextZ = Math.sin(nextAngle) * nextDistance;
                    
                    const width = Math.sqrt((nextX - x) ** 2 + (nextZ - z) ** 2) + 1;
                    const height = 8 + Math.random() * 4;
                    
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(width, height, 3 + Math.random()),
                        new THREE.MeshLambertMaterial({ color: 0x4a4a4a })
                    );
                    
                    wall.position.set((x + nextX) / 2, height / 2, (z + nextZ) / 2);
                    wall.rotation.y = angle + Math.PI / 2;
                    wall.castShadow = true;
                    this.scene.add(wall);
                    this.areaObjects.push(wall);
                }
                
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 40;
                    const z = (Math.random() - 0.5) * 40;
                    
                    const stream = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x4a90e2,
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    stream.position.set(x, 0.1, z);
                    stream.rotation.x = -Math.PI / 2;
                    this.scene.add(stream);
                    this.areaObjects.push(stream);
                }
            },

            createForest() {
                this.scene.background = new THREE.Color(0x2d5016);
                this.ground.material.color.setHex(0x2d5016);
                
                for (let i = 0; i < 50; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.sqrt(x * x + z * z) < 8);
                    
                    const trunkHeight = 4 + Math.random() * 2;
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.5, trunkHeight, 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a2511 })
                    );
                    trunk.position.set(x, trunkHeight / 2, z);
                    trunk.castShadow = true;
                    this.scene.add(trunk);
                    this.areaObjects.push(trunk);
                    
                    for (let j = 0; j < 3; j++) {
                        const leaves = new THREE.Mesh(
                            new THREE.ConeGeometry(2 - j * 0.4, 1.5, 8),
                            new THREE.MeshLambertMaterial({ color: 0x1a5a1a })
                        );
                        leaves.position.set(x, trunkHeight + 0.5 + j * 1, z);
                        leaves.castShadow = true;
                        this.scene.add(leaves);
                        this.areaObjects.push(leaves);
                    }
                }
                
                const dragonBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.0, 2.5, 4, 12),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonBody.position.set(0, 2.2, -8);
                dragonBody.castShadow = true;
                this.scene.add(dragonBody);
                this.areaObjects.push(dragonBody);
                
                const dragonNeck = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.9, 1.3, 2.5, 10),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonNeck.position.set(0, 4.8, -8);
                dragonNeck.rotation.z = 0.2;
                dragonNeck.castShadow = true;
                this.scene.add(dragonNeck);
                this.areaObjects.push(dragonNeck);
                
                const dragonHead = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 1.2, 2.0),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonHead.position.set(-0.4, 6.0, -7.5);
                dragonHead.castShadow = true;
                this.scene.add(dragonHead);
                this.areaObjects.push(dragonHead);
                
                const snout = new THREE.Mesh(
                    new THREE.ConeGeometry(0.6, 1.0, 8),
                    new THREE.MeshLambertMaterial({ color: 0x0066cc })
                );
                snout.position.set(-0.4, 6.0, -6.3);
                snout.rotation.x = Math.PI / 2;
                this.scene.add(snout);
                this.areaObjects.push(snout);
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 })
                );
                leftEye.position.set(-0.9, 6.1, -6.8);
                this.scene.add(leftEye);
                this.areaObjects.push(leftEye);
                
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 })
                );
                rightEye.position.set(0.1, 6.1, -6.8);
                this.scene.add(rightEye);
                this.areaObjects.push(rightEye);
                
                this.dragon = { 
                    body: dragonBody, 
                    neck: dragonNeck, 
                    head: dragonHead,
                    snout,
                    leftEye, 
                    rightEye,
                    baseX: -0.4,
                    baseY: 6.0,
                    baseZ: -7.5
                };
            },

            createFishing() {
                this.scene.background = new THREE.Color(0x87cefd);
                this.ground.material.color.setHex(0x1e90ff);
            },

            createWizard() {
                if (this.wizard) {
                    Object.values(this.wizard).forEach(part => { if (part && part.parent) this.scene.remove(part); });
                }
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.4, 8), new THREE.MeshLambertMaterial({ color: 0xf97316 }));
                body.position.set(-6, 0.7, 0);
                body.castShadow = true;
                this.scene.add(body);
                const face = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                face.position.set(-6, 1.5, 0.1);
                this.scene.add(face);
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffeb3b }));
                leftEye.position.set(-5.85, 1.52, 0.32);
                this.scene.add(leftEye);
                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffeb3b }));
                rightEye.position.set(-6.15, 1.52, 0.32);
                this.scene.add(rightEye);
                const hat = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 16), new THREE.MeshLambertMaterial({ color: 0xf97316 }));
                hat.position.set(-6, 2.4, 0);
                hat.castShadow = true;
                this.scene.add(hat);
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.8, 8), new THREE.MeshLambertMaterial({ color: 0x654321 }));
                staff.position.set(-5.35, 0.9, 0);
                staff.castShadow = true;
                this.scene.add(staff);
                this.wizard = { body, face, leftEye, rightEye, hat, staff, bobOffset: 0, baseX: -6, baseZ: 0 };
                this.wizardTarget = { x: -6, z: 0 };
            },

            setupEventListeners() {
                const canvas = document.getElementById('game-canvas');
                canvas.addEventListener('click', (e) => this.onCanvasClick(e));
            },

            onCanvasClick(e) {
                e.preventDefault();
                e.stopPropagation();
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                if (this.currentArea === 'farm') {
                    this.farmPlots.forEach(plot => {
                        if (plot.seed && plot.growthTime >= plot.growthNeeded && plot.plantMesh) {
                            const plotHits = this.raycaster.intersectObject(plot.mesh);
                            const plantHits = this.raycaster.intersectObject(plot.plantMesh, true);
                            if (plotHits.length > 0 || plantHits.length > 0) {
                                this.harvestPlant(plot);
                            }
                        }
                    });
                }
            },

            plantSeed(plot, tier) {
                if (!this.seeds[tier] || this.seeds[tier] <= 0 || plot.seed) return;
                plot.seed = tier;
                plot.growthTime = 0;
                this.seeds[tier]--;
                
                const plantGroup = new THREE.Group();
                const color = SEED_TIERS[tier - 1].color;
                
                // Add stem for ALL plants
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.08, 0.4, 6),
                    new THREE.MeshLambertMaterial({ color: 0x4a7c3a })
                );
                stem.position.y = 0.2;
                plantGroup.add(stem);
                
                // Add plant-specific top part
                if (tier === 1) {
                    const bush = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 8, 8),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.3 })
                    );
                    bush.position.y = 0.5;
                    bush.scale.set(1, 0.7, 1);
                    plantGroup.add(bush);
                } else if (tier === 2) {
                    const center = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 8, 8),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.5 })
                    );
                    center.position.y = 0.5;
                    plantGroup.add(center);
                    
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const petal = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 6, 6),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.4 })
                        );
                        petal.position.set(
                            Math.cos(angle) * 0.18,
                            0.5,
                            Math.sin(angle) * 0.18
                        );
                        petal.scale.set(1, 0.4, 1);
                        plantGroup.add(petal);
                    }
                }
                
                plantGroup.position.set(plot.x, 0.5, plot.z);
                plantGroup.scale.set(0.6, 0.6, 0.6);
                plantGroup.castShadow = true;
                this.scene.add(plantGroup);
                this.areaObjects.push(plantGroup);
                plot.plantMesh = plantGroup;
                this.renderToolbar();
            },

            harvestPlant(plot) {
                const tier = plot.seed;
                const gain = Math.floor(SEED_TIERS[tier - 1].sp * 1.2);
                this.essence += gain;
                this.stats.totalHarvests++;
                this.xp += tier * 4;
                this.checkLevel();
                this.seeds[tier] = (this.seeds[tier] || 0) + 1;
                if (tier < 5) this.seeds[tier + 1] = (this.seeds[tier + 1] || 0) + 1;
                if (plot.plantMesh) {
                    this.scene.remove(plot.plantMesh);
                    const idx = this.areaObjects.indexOf(plot.plantMesh);
                    if (idx > -1) this.areaObjects.splice(idx, 1);
                    plot.plantMesh = null;
                }
                plot.seed = null;
                plot.growthTime = 0;
                this.renderToolbar();
                this.updateUI();
            },

            checkLevel() {
                while (this.xp >= this.xpNeeded) {
                    this.xp -= this.xpNeeded;
                    this.level++;
                    this.xpNeeded = Math.floor(this.xpNeeded * 1.5);
                    this.maxHP += 15;
                    this.hp = this.maxHP;
                }
                this.updateUI();
            },

            switchArea(area) {
                if (area === 'mine' && !this.unlockedAreas.mine) {
                    if (this.essence >= 200) {
                        this.essence -= 200;
                        this.unlockedAreas.mine = true;
                        this.updateUI();
                    } else {
                        return;
                    }
                } else if (area === 'forest' && !this.unlockedAreas.forest) {
                    if (this.essence >= 1000) {
                        this.essence -= 1000;
                        this.unlockedAreas.forest = true;
                        this.updateUI();
                    } else {
                        return;
                    }
                }
                this.currentArea = area;
                this.createWorld();
                if (this.wizard) {
                    this.wizard.baseX = -6;
                    this.wizard.baseZ = 0;
                    this.wizardTarget = { x: -6, z: 0 };
                }
                this.renderToolbar();
            },

            renderToolbar() {
                const toolbar = document.getElementById('toolbar');
                toolbar.innerHTML = '';
                
                Object.keys(this.seeds).sort((a, b) => a - b).forEach(t => {
                    if (this.seeds[t] > 0) {
                        const s = SEED_TIERS[t - 1];
                        const item = document.createElement('div');
                        item.className = 'seed-item';
                        item.style.position = 'relative';
                        item.innerHTML = `<div class="seed-icon">${s.icon}</div><div class="seed-label">T${t}</div><div class="seed-count">${this.seeds[t]}</div>`;
                        item.addEventListener('click', () => {
                            if (this.currentArea === 'farm') {
                                const canvas = document.getElementById('game-canvas');
                                const rect = canvas.getBoundingClientRect();
                                canvas.addEventListener('click', (e) => {
                                    this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                                    this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                                    this.raycaster.setFromCamera(this.mouse, this.camera);
                                    this.farmPlots.forEach(plot => {
                                        const intersects = this.raycaster.intersectObject(plot.mesh);
                                        if (intersects.length > 0 && !plot.seed) {
                                            this.plantSeed(plot, parseInt(t));
                                        }
                                    });
                                }, { once: true });
                            }
                        });
                        toolbar.appendChild(item);
                    }
                });
            },

            updateUI() {
                document.getElementById('essence-display').textContent = Math.floor(this.essence);
                document.getElementById('level-display').textContent = `LVL ${this.level}`;
                document.getElementById('hp-bar').style.width = (this.hp / this.maxHP) * 100 + '%';
                document.getElementById('hp-text').textContent = `${Math.floor(this.hp)}/${this.maxHP}`;
                document.getElementById('xp-bar').style.width = (this.xp / this.xpNeeded) * 100 + '%';
                document.getElementById('xp-text').textContent = `${Math.floor(this.xp)}/${this.xpNeeded}`;
                document.getElementById('day-night-icon').textContent = this.isDayTime ? '‚òÄÔ∏è' : 'üåô';
                document.getElementById('day-night-text').textContent = this.isDayTime ? 'Day' : 'Night';
            },

            tick() {
                if (this.currentArea === 'farm') {
                    let speedMult = this.isDayTime ? 1.4 : 0.8;
                    this.farmPlots.forEach(plot => {
                        if (plot.seed && plot.plantMesh) {
                            plot.growthTime += 100 * speedMult;
                            const progress = Math.min(plot.growthTime / plot.growthNeeded, 1);
                            const targetScale = 0.4 + progress * 1.2;
                            const currentScale = plot.plantMesh.scale.x;
                            const newScale = currentScale + (targetScale - currentScale) * 0.1;
                            plot.plantMesh.scale.set(newScale, newScale, newScale);
                            plot.plantMesh.position.y = 0.5 + newScale * 0.4;
                            if (progress >= 1) {
                                plot.plantMesh.rotation.y += 0.05;
                                plot.plantMesh.children.forEach(child => {
                                    if (child.material && child.material.color) {
                                        child.material.emissive = child.material.color.clone();
                                        child.material.emissiveIntensity = 1.0;
                                    }
                                });
                            }
                        }
                    });
                }
                
                if (this.dragon && this.currentArea === 'forest') {
                    const time = Date.now() / 1000;
                    this.dragon.head.position.x = this.dragon.baseX + Math.sin(time * 0.3) * 0.2;
                    this.dragon.head.position.y = this.dragon.baseY + Math.sin(time * 0.4) * 0.15;
                    this.dragon.head.position.z = this.dragon.baseZ + Math.sin(time * 0.35) * 0.1;
                    this.dragon.head.rotation.y = Math.sin(time * 0.4) * 0.3;
                }
                
                if (this.wizard) {
                    this.wizard.bobOffset = Math.sin(Date.now() / 600) * 0.08;
                    this.wizard.body.position.y = 0.7 + this.wizard.bobOffset;
                    this.wizard.face.position.y = 1.5 + this.wizard.bobOffset;
                    this.wizard.leftEye.position.y = 1.52 + this.wizard.bobOffset;
                    this.wizard.rightEye.position.y = 1.52 + this.wizard.bobOffset;
                    this.wizard.hat.position.y = 2.4 + this.wizard.bobOffset;
                    this.wizard.staff.position.y = 0.9 + this.wizard.bobOffset;
                }
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateCamera();
                this.renderer.render(this.scene, this.camera);
            },

            toggleFullscreen() {
                const canvas = document.getElementById('game-canvas');
                const container = document.getElementById('game-container');
                const body = document.body;
                
                if (!document.fullscreenElement) {
                    body.classList.add('fullscreen-mode');
                    if (container.requestFullscreen) {
                        container.requestFullscreen().catch(err => {
                            console.log('Fullscreen request failed:', err);
                            body.classList.remove('fullscreen-mode');
                        });
                    } else if (container.webkitRequestFullscreen) {
                        container.webkitRequestFullscreen();
                    } else if (container.mozRequestFullScreen) {
                        container.mozRequestFullScreen();
                    } else if (container.msRequestFullscreen) {
                        container.msRequestFullscreen();
                    }
                } else {
                    body.classList.remove('fullscreen-mode');
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }
            },

            openModal(type) {},
        };

        window.onload = () => game.init();
    </script>
</body>
</html>
